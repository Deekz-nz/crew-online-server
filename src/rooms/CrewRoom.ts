/*
  GENERATED BY CHAT-GPT
*/
// File: src/rooms/CrewRoom.ts
import { Room, Client } from "colyseus";
import { Schema, type, MapSchema, ArraySchema } from "@colyseus/schema";
import { CrewGameState } from "./schema/CrewRoomState";
import { Card, CardColor, GameStage, Player } from "./schema/CrewTypes";


interface JoinOptions {
  displayName: string;
}

export class CrewRoom extends Room<CrewGameState> {
  maxClients = 5;

  onCreate(options: any) {
    this.state = new CrewGameState();

    this.onMessage("start_game", (client) => {
      const player = this.state.players.get(client.sessionId);
      
      // Check current game stage is "not started"
      if (this.state.currentGameStage != GameStage.NotStarted) return;

      // Check there is at least 3 players registered
      if (this.state.players.size <= 2) return;

      // Start the game

    })

    this.onMessage("play_card", (client, cardData: { color: string; number: number }) => {
      const player = this.state.players.get(client.sessionId);
      // Check that it is actually this person's turn
      if (!player || this.state.currentPlayer !== client.sessionId) return;

      // // Find and remove the card from player's hand
      // const cardIndex = player.hand.findIndex(
      //   (card) => card.color === cardData.color && card.number === cardData.number
      // );
      // if (cardIndex === -1) return; // Card not found

      // const [playedCard] = player.hand.splice(cardIndex, 1);
      // this.state.playedCards.push(playedCard);

      // // Switch turn to other player
      // const otherPlayerId = Array.from(this.state.players.keys()).find(
      //   (id) => id !== client.sessionId
      // );
      // if (otherPlayerId) {
      //   player.isMyTurn = false;
      //   this.state.players.get(otherPlayerId)!.isMyTurn = true;
      //   this.state.currentTurnSessionId = otherPlayerId;
      // }
    });
  }

  onJoin(client: Client, options: JoinOptions) {
    const player = new Player();
    player.sessionId = client.sessionId;

    // Get current player count for a fallback display name
    const playerCount = this.state.players.size + 1;
    player.displayName = options.displayName || "Player " + playerCount.toString();

    this.state.players.set(client.sessionId, player);
    this.state.playerOrder.push(client.sessionId);
  }

  onLeave(client: Client, consented: boolean) {
    this.state.players.delete(client.sessionId);
    this.state.players.delete(client.sessionId);
  }

  startGame() {
    this.state.currentGameStage = GameStage.GameSetup;

    // Create and shuffle the deck
    const deck = this.generateDeck();
    this.shuffle(deck);

    // Deal cards evenly
    const playerIds = Array.from(this.state.players.keys());
    while (deck.length) {
      for (const id of playerIds) {
        if (deck.length === 0) break;
        this.state.players.get(id)!.hand.push(deck.pop()!);
      }
    }

    // Determine who has black 4
    const starterId = playerIds.find(id =>
      this.state.players.get(id)!.hand.some(card => card.color === CardColor.Black && card.number === 4)
    );

    if (starterId) {
      this.state.currentPlayer = starterId;
    } else {
      console.log("Uh oh, can't find the Black 4 in anyone's hand??!");
    }

    this.state.currentGameStage = GameStage.TrickStart;
  }

  generateDeck(): Card[] {
    const colors = [CardColor.Yellow, CardColor.Green, CardColor.Pink, CardColor.Blue];
    const deck: Card[] = [];

    for (const color of colors) {
      for (let num = 1; num <= 9; num++) {
        const card = new Card();
        card.color = color;
        card.number = num;
        deck.push(card);
      }
    }
    for (let num = 1; num <= 4; num++) {
      const card = new Card();
      card.color = CardColor.Black;
      card.number = num;
      deck.push(card);
    }

    return deck;
  }

  shuffle(array: Card[]) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
}
