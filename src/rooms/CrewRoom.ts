/*
  GENERATED BY CHAT-GPT
*/
// File: src/rooms/CrewRoom.ts
import { Room, Client } from "colyseus";
import { Schema, type, MapSchema, ArraySchema } from "@colyseus/schema";
import { CrewGameState } from "./schema/CrewRoomState";
import { Card, CardColor, CommunicationRank, GameStage, Player, SimpleTask, Trick } from "./schema/CrewTypes";


interface JoinOptions {
  displayName: string;
}

interface GameSetupInstructions {
  includeTasks: boolean;
  taskInstructions: {
    plainTasks: number;
    orderedTasks: number;
    sequencedTasks: number;
    lastTask: boolean;
  }
}
export class CrewRoom extends Room<CrewGameState> {
  maxClients = 5;

  onCreate(options: any) {
    this.state = new CrewGameState();

    // GameStage = NotStarted
    this.onMessage("start_game", (client, gameSetupInstructions: GameSetupInstructions) => {
      // TODO: Implement concept of a 'host' (the first player) - only they can set up game and start it.
      const player = this.state.players.get(client.sessionId);
      
      // Check current game stage is "not started"
      if (this.state.currentGameStage != GameStage.NotStarted) return;

      // Check there is at least 3 players registered
      if (this.state.players.size <= 2) return;

      // Start the game
      this.startGame(gameSetupInstructions);

    })

    // GameStage = GameSetup
    this.onMessage("take_task", (client, taskData: SimpleTask) => {
      if (this.state.currentGameStage !== GameStage.GameSetup) return;
    
      const player = this.state.players.get(client.sessionId);
      if (!player) return;
    
      // Find task in availableTasks
      const taskIndex = this.state.availableTasks.findIndex(task =>
        this.isSameTask(task, taskData)
      );
      if (taskIndex === -1) return; // Task not found
    
      const [task] = this.state.availableTasks.splice(taskIndex, 1);
      task.player = client.sessionId; // Assign task to player
      player.hasTasks.push(task);
    });

    // GameStage = GameSetup
    this.onMessage("return_task", (client, taskData: SimpleTask) => {
      if (this.state.currentGameStage !== GameStage.GameSetup) return;
    
      const player = this.state.players.get(client.sessionId);
      if (!player) return;
    
      // Find task in player's tasks
      const taskIndex = player.hasTasks.findIndex(task =>
        this.isSameTask(task, taskData)
      );
      if (taskIndex === -1) return; // Task not found
    
      const [task] = player.hasTasks.splice(taskIndex, 1);
      task.player = ""; // Reset player assignment
      this.state.availableTasks.push(task);
    });

    // GameStage = GameSetup
    this.onMessage("finish_task_allocation", (client) => {
      if (this.state.currentGameStage !== GameStage.GameSetup) return;
    
      if (this.state.availableTasks.length > 0) return; // Not all tasks taken
    
      this.state.currentGameStage = GameStage.TrickStart;
    });

    // GameStage = TrickStart or TrickMiddle
    this.onMessage("play_card", (client, cardData: { color: CardColor; number: number }) => {
      const player = this.state.players.get(client.sessionId);
      // Check GameStage
      if (this.state.currentGameStage !== GameStage.TrickStart && this.state.currentGameStage !== GameStage.TrickMiddle) return;

      // Check that it is actually this person's turn
      if (!player || this.state.currentPlayer !== client.sessionId) return;

      // Find and remove the card from player's hand
      const cardIndex = player.hand.findIndex(
        (card) => card.color === cardData.color && card.number === cardData.number
      );
      if (cardIndex === -1) return; // Card not found

      // Remove card from player's hand
      const [playedCard] = player.hand.splice(cardIndex, 1);

        // Check if this card was communicated — track whether we cleared it in case we revert
      let communicationCleared = false;
      if (
        player.hasCommunicated &&
        player.communicationCard.color === playedCard.color &&
        player.communicationCard.number === playedCard.number
      ) {
        player.communicationCard = new Card(); // Reset to empty card
        player.communicationRank = CommunicationRank.Unknown;
        communicationCleared = true;
      }

      const trick = this.state.currentTrick;

      if (this.state.currentGameStage === GameStage.TrickStart) {
        // === First card of the trick ===
        // Update state
        const newTrick = new Trick();
        newTrick.playedCards.push(playedCard);
        newTrick.playerOrder.push(client.sessionId);
        newTrick.trickCompleted = false;
        this.state.currentTrick = newTrick;
    
        // Advance game stage to TrickMiddle
        this.state.currentGameStage = GameStage.TrickMiddle;
        this.state.currentPlayer = this.getNextPlayer(client.sessionId);
      } else if (this.state.currentGameStage === GameStage.TrickMiddle) {
        // It's NOT the first card, so we have to make sure the player isn't re-negging
        // i.e. if the first card in the trick was a blue, and the player is NOT playing a blue, then check to make sure they have no blues
        const leadCard = trick.playedCards[0];

        if (playedCard.color !== leadCard.color) {
          const hasLeadColor = player.hand.some((card) => card.color === leadCard.color);
          if (hasLeadColor) {
            // Player is re-negging — revert card removal and ignore play
            player.hand.push(playedCard); // Add card back to hand
            if (communicationCleared) { // Restore communication
              player.hasCommunicated = true;
              player.communicationCard = playedCard;
            }
            return;
          }
        }
        // Add played card to trick
        trick.playedCards.push(playedCard);
        trick.playerOrder.push(client.sessionId);

        // Now check - is trick finished?
        if (trick.playedCards.length === this.state.playerOrder.length) {
          const winnerId = this.determineTrickWinner(trick);
          trick.trickWinner = winnerId;
          trick.trickCompleted = true;
          this.state.currentPlayer = winnerId;
          this.state.currentGameStage = GameStage.TrickEnd;
          this.state.completedTricks.push(trick);
        } else {
          // Trick still going - move to next player
          this.state.currentPlayer = this.getNextPlayer(client.sessionId);
        }
      } else {
        // Invalid game stage - put card back
        player.hand.push(playedCard); // Add card back to hand
        if (communicationCleared) { // Restore communication
          player.hasCommunicated = true;
          player.communicationCard = playedCard;
        }
        return;
      }

    });

    // GameStage = TrickEnd
    this.onMessage("finish_trick", (client) => {
      const player = this.state.players.get(client.sessionId);
      
      // Check current game stage is "TrickEnd"
      if (this.state.currentGameStage != GameStage.TrickEnd) return;

      // Check that it is actually this person's turn
      if (!player || this.state.currentPlayer !== client.sessionId) return;

      // Determine how many tricks are expected based on number of players
      const numPlayers = this.state.playerOrder.length;
      let totalTricksExpected = 0;

      switch (numPlayers) {
        case 5: totalTricksExpected = 8; break;
        case 4: totalTricksExpected = 10; break;
        case 3: totalTricksExpected = 13; break;
        default: return; // Invalid player count
      }
      
      const tricksPlayed = this.state.completedTricks.length;

      if (tricksPlayed >= totalTricksExpected) {
        // All tricks played: count how many each player won
        const trickWins = new Map<string, number>(); // sessionId -> win count
    
        for (const trick of this.state.completedTricks) {
          const winnerId = trick.trickWinner;
          if (winnerId) {
            trickWins.set(winnerId, (trickWins.get(winnerId) || 0) + 1);
          }
        }
    
        // For now, just console log
        console.log("Trick wins per player:", Array.from(trickWins.entries()));
    
        this.state.currentGameStage = GameStage.GameEnd;
        this.state.currentTrick = new Trick();
    
      } else {
        // More tricks to play: reset for next trick
        this.state.currentTrick = new Trick();
        this.state.currentGameStage = GameStage.TrickStart;
        // currentPlayer remains unchanged (winner of last trick leads next)
      }
    });

    //GameStage = TrickEnd or TrickStart
    this.onMessage("communicate", (client, details: { card: Card, cardRank: CommunicationRank }) => {
      const player = this.state.players.get(client.sessionId);
      // Check GameStage
      if (this.state.currentGameStage !== GameStage.TrickStart && this.state.currentGameStage !== GameStage.TrickEnd) return;
      
      // Check if Player has already communicated
      if (player.hasCommunicated) return;

      // Check if communication is valid
      if (!this.isValidCommunication(player, details.card, details.cardRank)) {
        return;
      }
      
      // Update player's communication
      player.hasCommunicated = true;
      player.communicationCard = details.card;
      player.communicationRank = details.cardRank;
      

    })

  }

  onJoin(client: Client, options: JoinOptions) {
    // TODO: If game has started, don't let anyone join
    const player = new Player();
    player.sessionId = client.sessionId;

    // Get current player count for a fallback display name
    const playerCount = this.state.players.size + 1;
    player.displayName = options.displayName || "Player " + playerCount.toString();

    this.state.players.set(client.sessionId, player);
    this.state.playerOrder.push(client.sessionId);
  }

  onLeave(client: Client, consented: boolean) {
    this.state.players.delete(client.sessionId);
    const index = this.state.playerOrder.indexOf(client.sessionId);
    if (index !== -1) this.state.playerOrder.splice(index, 1);
  }

  startGame(gameSetupInstructions: GameSetupInstructions) {
    this.state.currentGameStage = GameStage.GameSetup;
    this.state.gameStarted = true;

    // Create and shuffle the deck
    const deck = this.generateDeck();
    this.shuffle(deck);

    // Deal cards evenly
    const playerIds = Array.from(this.state.players.keys());
  
    // Randomize starting index
    const startIndex = Math.floor(Math.random() * playerIds.length);

    // Deal cards starting from random player
    let dealIndex = startIndex;
    while (deck.length) {
      const playerId = playerIds[dealIndex % playerIds.length];
      this.state.players.get(playerId)!.hand.push(deck.pop()!);
      dealIndex++;
    }

    // Determine who has black 4
    const starterId = playerIds.find(id =>
      this.state.players.get(id)!.hand.some(card => card.color === CardColor.Black && card.number === 4)
    );

    if (starterId) {
      this.state.currentPlayer = starterId;
      this.state.commanderPlayer = starterId;
    } else {
      console.log("Uh oh, can't find the Black 4 in anyone's hand??!");
    }

    // Check if we are creating tasks
    if (gameSetupInstructions.includeTasks) {
      const generatedTasks = this.generateTasks(gameSetupInstructions.taskInstructions);
      this.state.availableTasks.push(...generatedTasks);
    }
    // this.state.currentGameStage = GameStage.TrickStart;
  }

  generateDeck(includeBlackCards: boolean = true): Card[] {
    const colors = [CardColor.Yellow, CardColor.Green, CardColor.Pink, CardColor.Blue];
    const deck: Card[] = [];
  
    for (const color of colors) {
      for (let num = 1; num <= 9; num++) {
        const card = new Card();
        card.color = color;
        card.number = num;
        deck.push(card);
      }
    }
  
    if (includeBlackCards) {
      for (let num = 1; num <= 4; num++) {
        const card = new Card();
        card.color = CardColor.Black;
        card.number = num;
        deck.push(card);
      }
    }
  
    return deck;
  }

  generateTasks(instructions: GameSetupInstructions["taskInstructions"]): SimpleTask[] {
    // === Build a pool of all cards ===
    const cardPool = this.generateDeck(false); // No black cards for tasks
    this.shuffle(cardPool);
  
    const taskList: SimpleTask[] = [];
  
    // Helper to pop a card from the pool
    const drawCard = (): Card | null => {
      return cardPool.length > 0 ? cardPool.pop()! : null;
    };
  
    // Now create tasks and to add to the game state
    // taskInstructions: {
    //   plainTasks: number; Create this many tasks where taskNumber = 0, sequence = 0, mustBeLast = false
    //   orderedTasks: number; Create this many tasks where sequence = 0, mustBeLast = false, and taskNumber is incrementing starting at 1
    //   sequencedTasks: number; Create this many tasks where taskNumber = 0, mustBeLast = false, and Sequence is incrementing starting at 1
    //   lastTask: boolean; Create one task where sequence = 0, taskNumber = 0, mustBeLast = true
    // }

    // === Plain Tasks ===
    for (let i = 0; i < instructions.plainTasks; i++) {
      const card = drawCard();
      if (!card) break;
      const task = new SimpleTask();
      task.card = card;
      task.player = "";
      task.taskNumber = 0;
      task.sequence = 0;
      task.mustBeLast = false;
      taskList.push(task);
    }
  
    // === Ordered Tasks ===
    for (let i = 1; i <= instructions.orderedTasks; i++) {
      const card = drawCard();
      if (!card) break;
      const task = new SimpleTask();
      task.card = card;
      task.player = "";
      task.taskNumber = i;
      task.sequence = 0;
      task.mustBeLast = false;
      taskList.push(task);
    }
  
    // === Sequenced Tasks ===
    for (let i = 1; i <= instructions.sequencedTasks; i++) {
      const card = drawCard();
      if (!card) break;
      const task = new SimpleTask();
      task.card = card;
      task.player = "";
      task.taskNumber = 0;
      task.sequence = i;
      task.mustBeLast = false;
      taskList.push(task);
    }
  
    // === Last Task ===
    if (instructions.lastTask) {
      const card = drawCard();
      if (card) {
        const task = new SimpleTask();
        task.card = card;
        task.player = "";
        task.taskNumber = 0;
        task.sequence = 0;
        task.mustBeLast = true;
        taskList.push(task);
      }
    }
  
    return taskList;
  }

  isSameTask(taskA: SimpleTask, taskB: SimpleTask): boolean {
    return (
      taskA.card.color === taskB.card.color &&
      taskA.card.number === taskB.card.number &&
      taskA.taskNumber === taskB.taskNumber &&
      taskA.sequence === taskB.sequence &&
      taskA.mustBeLast === taskB.mustBeLast
    );
  }
  
  shuffle(array: Card[]) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  getNextPlayer(currentPlayer: string) {
    const currentIndex = this.state.playerOrder.indexOf(currentPlayer);
    const nextIndex = (currentIndex + 1) % this.state.playerOrder.length;
    return this.state.playerOrder[nextIndex];
  }

  determineTrickWinner(trick: Trick) {
    const playedCards = trick.playedCards;
    const playerOrder = trick.playerOrder;
  
    let winningIndex = 0;
    let highestValue = -1;
  
    // First, check for any black cards
    let blackCardPlayed = false;
  
    playedCards.forEach((card, idx) => {
      if (card.color === CardColor.Black) {
        blackCardPlayed = true;
        if (card.number > highestValue) {
          highestValue = card.number;
          winningIndex = idx;
        }
      }
    });
  
    if (!blackCardPlayed) {
      // No black cards, determine winner by lead suit
      const leadColor = playedCards[0].color;
      highestValue = -1;
  
      playedCards.forEach((card, idx) => {
        if (card.color === leadColor && card.number > highestValue) {
          highestValue = card.number;
          winningIndex = idx;
        }
      });
    }
  
    return playerOrder[winningIndex]; // Return the sessionId of the winning player
  }

  // Check the communication rank, and whether this is a valid communicate (also check they have the card they're trying to communicate)
  // - Highest iff they have more than one of that colour and this is the highest number
  // - Lowest iff they have more than one of that colour and this is the lowest number
  // - Only iff they have only one of that colour
  // - Unknown is allowed iff exactly one of the above is true
  isValidCommunication(
    player: Player,
    card: Card,
    rank: CommunicationRank
  ): boolean {
    // Find all cards in player's hand of the same color
    const sameColorCards = player.hand.filter((c) => c.color === card.color);
  
    if (sameColorCards.length === 0) return false; // Player doesn't have any card of that color
    const numbers = sameColorCards.map((c) => c.number);
    const maxNumber = Math.max(...numbers);
    const minNumber = Math.min(...numbers);
  
    // Confirm player actually has the communicated card
    const hasCard = sameColorCards.some(
      (c) => c.number === card.number
    );
    if (!hasCard) return false;
  
    switch (rank) {
      case CommunicationRank.Only:
        return sameColorCards.length === 1;
  
      case CommunicationRank.Highest:
        return sameColorCards.length > 1 && card.number === maxNumber;
  
      case CommunicationRank.Lowest:
        return sameColorCards.length > 1 && card.number === minNumber;
  
      case CommunicationRank.Unknown:
        const isHighest = card.number === maxNumber && sameColorCards.length > 1;
        const isLowest = card.number === minNumber && sameColorCards.length > 1;
        const isOnly = sameColorCards.length === 1;
        const validRanks = [isHighest, isLowest, isOnly].filter((v) => v);
        return validRanks.length === 1; // Exactly one condition is true
  
      default:
        return false;
    }
  }
}
